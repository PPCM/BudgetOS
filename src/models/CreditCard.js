import knex from '../database/connection.js';
import dateHelpers from '../database/dateHelpers.js';
import { generateId, roundAmount, calculateDeferredDebitDate, getCycleForPurchase, formatDateISO } from '../utils/helpers.js';
import { NotFoundError } from '../utils/errors.js';
import { addMonths, setDate, subDays, endOfMonth, startOfMonth, format } from 'date-fns';
import { buildUpdates } from '../utils/modelHelpers.js';

/**
 * Parse a MM/YY expiration date string and return a comparable numeric value.
 * Returns null for invalid or empty values.
 * The numeric value is YYYY * 100 + MM, e.g. "01/26" => 202601.
 * @param {string} expirationDate - Expiration date in MM/YY format
 * @returns {number|null}
 */
function parseExpirationValue(expirationDate) {
  if (!expirationDate || expirationDate.trim() === '') return null;
  const parts = expirationDate.split('/');
  if (parts.length !== 2) return null;
  const month = parseInt(parts[0], 10);
  const year = parseInt(parts[1], 10) + 2000;
  if (isNaN(month) || isNaN(year)) return null;
  return year * 100 + month;
}

/**
 * Get current year/month as a comparable numeric value (YYYY * 100 + MM).
 * @returns {number}
 */
function currentYearMonth() {
  const now = new Date();
  return now.getFullYear() * 100 + (now.getMonth() + 1);
}

/**
 * Check whether an expiration date string (MM/YY) is expired.
 * Cards without expiration date are considered non-expired.
 * @param {string} expirationDate
 * @returns {boolean}
 */
function isExpired(expirationDate) {
  const val = parseExpirationValue(expirationDate);
  if (val === null) return false;
  return val < currentYearMonth();
}

/**
 * CreditCard model
 */
export class CreditCard {
  /**
   * Create a new credit card
   */
  static async create(userId, data) {
    const id = generateId();

    await knex('credit_cards').insert({
      id,
      user_id: userId,
      account_id: data.accountId,
      linked_account_id: data.linkedAccountId || null,
      name: data.name,
      card_number_last4: data.cardNumberLast4 || null,
      expiration_date: data.expirationDate || null,
      debit_type: data.debitType,
      cycle_start_day: data.cycleStartDay || 1,
      debit_day: data.debitDay || null,
      debit_days_before_end: data.debitDaysBeforeEnd || null,
      credit_limit: data.creditLimit || null,
      has_dedicated_account: !!data.hasDedicatedAccount,
      auto_generate_debit: data.autoGenerateDebit !== false,
      color: data.color || '#EF4444',
      notes: data.notes || null,
    });

    // Create the first cycle if it's a deferred debit card
    if (data.debitType === 'deferred') {
      await CreditCard.createCurrentCycle(id, userId);
    }

    return CreditCard.findById(id, userId);
  }

  /**
   * Find a card by ID
   */
  static async findById(id, userId) {
    const card = await knex('credit_cards as cc')
      .leftJoin('accounts as a', 'cc.account_id', 'a.id')
      .leftJoin('accounts as la', 'cc.linked_account_id', 'la.id')
      .select(
        'cc.*',
        'a.name as account_name',
        'la.name as linked_account_name'
      )
      .where({ 'cc.id': id, 'cc.user_id': userId, 'cc.is_active': true })
      .first();

    return card ? CreditCard.format(card) : null;
  }

  /**
   * Find a card or throw an error
   */
  static async findByIdOrFail(id, userId) {
    const card = await CreditCard.findById(id, userId);
    if (!card) {
      throw new NotFoundError('Credit card not found', 'CREDIT_CARD_NOT_FOUND');
    }
    return card;
  }

  /**
   * List cards for a user
   */
  static async findByUser(userId, options = {}) {
    const { isActive = true, includeBalances = true, status, sortBy = 'name', sortOrder = 'asc' } = options;

    let query = knex('credit_cards as cc')
      .leftJoin('accounts as a', 'cc.account_id', 'a.id')
      .leftJoin('accounts as la', 'cc.linked_account_id', 'la.id')
      .select(
        'cc.*',
        'a.name as account_name',
        'la.name as linked_account_name'
      )
      .where('cc.user_id', userId);

    if (isActive !== undefined) {
      query = query.where('cc.is_active', !!isActive);
    }

    // Apply non-expiration-related sorting at the DB level
    const validSortFields = ['name', 'expiration_date', 'created_at'];
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'name';
    const order = sortOrder === 'desc' ? 'desc' : 'asc';

    if (sortField !== 'expiration_date') {
      query = query.orderBy(`cc.${sortField}`, order);
    }

    let cards = await query;

    // Filter by expiration status in JS for cross-database compatibility
    if (status === 'active') {
      cards = cards.filter(card => !isExpired(card.expiration_date));
    } else if (status === 'expired') {
      cards = cards.filter(card => {
        // Must have an expiration date AND be expired
        const val = parseExpirationValue(card.expiration_date);
        return val !== null && val < currentYearMonth();
      });
    }

    // Handle expiration_date sorting in JS (nulls last)
    if (sortField === 'expiration_date') {
      cards.sort((a, b) => {
        const valA = parseExpirationValue(a.expiration_date);
        const valB = parseExpirationValue(b.expiration_date);

        // Nulls go to the end
        if (valA === null && valB === null) return 0;
        if (valA === null) return 1;
        if (valB === null) return -1;

        return order === 'asc' ? valA - valB : valB - valA;
      });
    }

    // Add current cycle balances if requested
    if (includeBalances) {
      const deferredCards = cards.filter(c => c.debit_type === 'deferred');
      const deferredCardIds = deferredCards.map(c => c.id);

      let cycleBalanceMap = {};
      let pendingAmountMap = {};

      if (deferredCardIds.length > 0) {
        const balances = await CreditCard.getBalancesForCards(deferredCardIds);
        cycleBalanceMap = balances.cycleBalances;
        pendingAmountMap = balances.pendingAmounts;
      }

      return cards.map(card => {
        const formatted = CreditCard.format(card);
        if (card.debit_type === 'deferred') {
          formatted.currentCycleBalance = cycleBalanceMap[card.id] || 0;
          formatted.pendingDebitAmount = pendingAmountMap[card.id] || 0;
        }
        return formatted;
      });
    }

    return cards.map(CreditCard.format);
  }

  /**
   * Batch-load cycle balances and pending debit amounts for multiple cards.
   * Replaces N+1 individual calls with 2 batch queries.
   */
  static async getBalancesForCards(cardIds) {
    if (!cardIds.length) return { cycleBalances: {}, pendingAmounts: {} };

    // 1 query: sum of ABS(amount) for open cycles per card
    const cycleRows = await knex('credit_card_cycles as ccc')
      .join('transactions as t', 't.credit_card_cycle_id', 'ccc.id')
      .whereIn('ccc.credit_card_id', cardIds)
      .where('ccc.status', 'open')
      .whereNot('t.status', 'void')
      .groupBy('ccc.credit_card_id')
      .select('ccc.credit_card_id')
      .select(knex.raw('SUM(ABS(t.amount)) as balance'));

    const cycleBalances = {};
    for (const row of cycleRows) {
      cycleBalances[row.credit_card_id] = roundAmount(row.balance || 0);
    }

    // 1 query: sum of total_amount for pending cycles per card
    const pendingRows = await knex('credit_card_cycles')
      .whereIn('credit_card_id', cardIds)
      .where('status', 'pending')
      .groupBy('credit_card_id')
      .select('credit_card_id')
      .sum('total_amount as total');

    const pendingAmounts = {};
    for (const row of pendingRows) {
      pendingAmounts[row.credit_card_id] = roundAmount(row.total || 0);
    }

    return { cycleBalances, pendingAmounts };
  }

  /**
   * Update a card
   */
  static async update(id, userId, data) {
    await CreditCard.findByIdOrFail(id, userId);

    const allowedFields = [
      'linked_account_id', 'name', 'card_number_last4', 'expiration_date', 'debit_type',
      'cycle_start_day', 'debit_day', 'debit_days_before_end',
      'credit_limit', 'has_dedicated_account', 'auto_generate_debit', 'color', 'notes'
    ];

    const updates = buildUpdates(data, allowedFields);

    if (Object.keys(updates).length > 0) {
      await knex('credit_cards')
        .where({ id, user_id: userId })
        .update(updates);
    }

    return CreditCard.findById(id, userId);
  }

  /**
   * Delete a card (soft delete)
   */
  static async delete(id, userId) {
    await CreditCard.findByIdOrFail(id, userId);
    await knex('credit_cards')
      .where({ id, user_id: userId })
      .update({ is_active: false });
    return { deleted: true };
  }

  /**
   * Create a billing cycle
   */
  static async createCycle(cardId, userId, cycleStart, cycleEnd, debitDate) {
    const id = generateId();

    await knex('credit_card_cycles').insert({
      id,
      credit_card_id: cardId,
      cycle_start_date: cycleStart,
      cycle_end_date: cycleEnd,
      debit_date: debitDate,
      status: 'open',
    });

    return id;
  }

  /**
   * Create the current cycle for a card
   */
  static async createCurrentCycle(cardId, userId) {
    const card = await knex('credit_cards').where({ id: cardId }).first();
    if (!card || card.debit_type !== 'deferred') return null;

    const today = new Date();
    const cycleStartDay = card.cycle_start_day || 1;

    // Determine current cycle dates
    let cycleStart, cycleEnd;
    if (today.getDate() >= cycleStartDay) {
      cycleStart = setDate(today, cycleStartDay);
      cycleEnd = subDays(setDate(addMonths(today, 1), cycleStartDay), 1);
    } else {
      cycleStart = setDate(addMonths(today, -1), cycleStartDay);
      cycleEnd = subDays(setDate(today, cycleStartDay), 1);
    }

    // Calculate the debit date
    let debitDate;
    if (card.debit_day) {
      debitDate = setDate(addMonths(cycleEnd, 1), card.debit_day);
    } else if (card.debit_days_before_end) {
      debitDate = subDays(endOfMonth(addMonths(cycleEnd, 1)), card.debit_days_before_end);
    } else {
      debitDate = setDate(addMonths(cycleEnd, 1), 5);
    }

    // Check if the cycle already exists
    const existing = await knex('credit_card_cycles')
      .where({ credit_card_id: cardId, cycle_start_date: formatDateISO(cycleStart) })
      .first();

    if (existing) return existing.id;

    return CreditCard.createCycle(
      cardId, userId,
      formatDateISO(cycleStart),
      formatDateISO(cycleEnd),
      formatDateISO(debitDate)
    );
  }

  /**
   * Get the current cycle for a card
   */
  static async getCurrentCycle(cardId, userId) {
    await CreditCard.findByIdOrFail(cardId, userId);

    const cycle = await knex('credit_card_cycles')
      .where({ credit_card_id: cardId, status: 'open' })
      .orderBy('cycle_start_date', 'desc')
      .first();

    return cycle ? CreditCard.formatCycle(cycle) : null;
  }

  /**
   * List cycles for a card
   */
  static async getCycles(cardId, userId, options = {}) {
    await CreditCard.findByIdOrFail(cardId, userId);

    const { status, startDate, endDate, page = 1, limit = 12 } = options;

    let query = knex('credit_card_cycles')
      .where('credit_card_id', cardId);

    if (status) {
      query = query.where('status', status);
    }

    if (startDate) {
      query = query.where('cycle_start_date', '>=', startDate);
    }

    if (endDate) {
      query = query.where('cycle_end_date', '<=', endDate);
    }

    const cycles = await query
      .leftJoin('transactions as t', function () {
        this.on('credit_card_cycles.id', '=', 't.credit_card_cycle_id')
          .andOnVal('t.status', '!=', 'void');
      })
      .select(
        'credit_card_cycles.*',
        knex.raw('COALESCE(SUM(ABS(t.amount)), 0) as total_amount_calc'),
        knex.raw('COUNT(t.id) as transaction_count')
      )
      .groupBy('credit_card_cycles.id')
      .orderBy('cycle_start_date', 'desc')
      .limit(limit)
      .offset((page - 1) * limit);

    return cycles.map(cycle => {
      const formatted = CreditCard.formatCycle(cycle);
      formatted.totalAmount = roundAmount(cycle.total_amount_calc || 0);
      formatted.transactionCount = Number(cycle.transaction_count || 0);
      return formatted;
    });
  }

  /**
   * Get the total for a cycle
   */
  static async getCycleTotal(cycleId) {
    const result = await knex('transactions')
      .where('credit_card_cycle_id', cycleId)
      .select(knex.raw('COALESCE(SUM(ABS(amount)), 0) as total'))
      .first();

    return roundAmount(result?.total || 0);
  }

  /**
   * Count transactions in a cycle
   */
  static async getCycleTransactionCount(cycleId) {
    const result = await knex('transactions')
      .where('credit_card_cycle_id', cycleId)
      .count('* as count')
      .first();

    return Number(result?.count || 0);
  }

  /**
   * Get the current cycle balance
   */
  static async getCurrentCycleBalance(cardId, userId) {
    const cycle = await CreditCard.getCurrentCycle(cardId, userId);
    if (!cycle) return 0;

    return CreditCard.getCycleTotal(cycle.id);
  }

  /**
   * Get the pending debit amount
   */
  static async getPendingDebitAmount(cardId, userId) {
    const result = await knex('credit_card_cycles')
      .where({ credit_card_id: cardId, status: 'pending' })
      .select(knex.raw('COALESCE(SUM(total_amount), 0) as total'))
      .first();

    return roundAmount(result?.total || 0);
  }

  /**
   * Get transactions for a cycle
   */
  static async getCycleTransactions(cycleId, userId) {
    const transactions = await knex('transactions as t')
      .leftJoin('categories as c', 't.category_id', 'c.id')
      .select(
        't.*',
        'c.name as category_name'
      )
      .where({ 't.credit_card_cycle_id': cycleId, 't.user_id': userId })
      .orderBy('t.purchase_date', 'desc')
      .orderBy('t.date', 'desc');

    return transactions.map(tx => ({
      id: tx.id,
      amount: Number(tx.amount),
      description: tx.description,
      date: tx.date,
      purchaseDate: tx.purchase_date,
      categoryId: tx.category_id,
      categoryName: tx.category_name,
      status: tx.status,
    }));
  }

  /**
   * Assign a transaction to a cycle
   */
  static async assignTransactionToCycle(transactionId, cardId, userId) {
    const card = await CreditCard.findByIdOrFail(cardId, userId);
    if (card.debitType !== 'deferred') return null;

    const tx = await knex('transactions')
      .where({ id: transactionId, user_id: userId })
      .first();
    if (!tx) return null;

    const purchaseDate = tx.purchase_date || tx.date;
    const cycle = getCycleForPurchase(purchaseDate, card.cycleStartDay);

    // Find or create the cycle
    let cycleRecord = await knex('credit_card_cycles')
      .where({ credit_card_id: cardId, cycle_start_date: cycle.start })
      .first();

    if (!cycleRecord) {
      // Calculate the debit date
      const cycleEndDate = new Date(cycle.end);
      let debitDate;
      if (card.debitDay) {
        debitDate = setDate(addMonths(cycleEndDate, 1), card.debitDay);
      } else if (card.debitDaysBeforeEnd) {
        debitDate = subDays(endOfMonth(addMonths(cycleEndDate, 1)), card.debitDaysBeforeEnd);
      } else {
        debitDate = setDate(addMonths(cycleEndDate, 1), 5);
      }

      const cycleId = await CreditCard.createCycle(cardId, userId, cycle.start, cycle.end, formatDateISO(debitDate));
      cycleRecord = { id: cycleId };
    }

    // Assign the transaction to the cycle
    await knex('transactions')
      .where({ id: transactionId })
      .update({
        credit_card_cycle_id: cycleRecord.id,
        accounting_date: cycle.end,
      });

    // Update the cycle total
    const total = await CreditCard.getCycleTotal(cycleRecord.id);
    await knex('credit_card_cycles')
      .where({ id: cycleRecord.id })
      .update({ total_amount: total });

    return cycleRecord.id;
  }

  /**
   * Generate the monthly debit for a cycle
   */
  static async generateCycleDebit(cycleId, userId) {
    const cycle = await knex('credit_card_cycles').where({ id: cycleId }).first();
    if (!cycle || cycle.status !== 'pending') return null;

    const card = await knex('credit_cards').where({ id: cycle.credit_card_id }).first();
    if (!card || !card.linked_account_id) return null;

    const debitId = generateId();

    await knex.transaction(async (trx) => {
      // Create the debit transaction
      await trx('transactions').insert({
        id: debitId,
        user_id: userId,
        account_id: card.linked_account_id,
        credit_card_id: card.id,
        credit_card_cycle_id: cycleId,
        amount: -cycle.total_amount,
        description: `Prélèvement carte ${card.name}`,
        date: cycle.debit_date,
        status: 'cleared',
        type: 'expense',
      });

      // Mark the cycle as debited
      await trx('credit_card_cycles')
        .where({ id: cycleId })
        .update({
          status: 'debited',
          debit_transaction_id: debitId,
        });
    });

    return debitId;
  }

  /**
   * Format a card for the API
   */
  static format(card) {
    return {
      id: card.id,
      userId: card.user_id,
      accountId: card.account_id,
      accountName: card.account_name,
      linkedAccountId: card.linked_account_id,
      linkedAccountName: card.linked_account_name,
      name: card.name,
      cardNumberLast4: card.card_number_last4,
      expirationDate: card.expiration_date,
      debitType: card.debit_type,
      cycleStartDay: card.cycle_start_day,
      debitDay: card.debit_day,
      debitDaysBeforeEnd: card.debit_days_before_end,
      creditLimit: card.credit_limit != null ? Number(card.credit_limit) : null,
      hasDedicatedAccount: Boolean(card.has_dedicated_account),
      autoGenerateDebit: Boolean(card.auto_generate_debit),
      isActive: Boolean(card.is_active),
      color: card.color,
      notes: card.notes,
      createdAt: card.created_at,
      updatedAt: card.updated_at,
    };
  }

  /**
   * Format a cycle for the API
   */
  static formatCycle(cycle) {
    return {
      id: cycle.id,
      creditCardId: cycle.credit_card_id,
      cycleStartDate: cycle.cycle_start_date,
      cycleEndDate: cycle.cycle_end_date,
      debitDate: cycle.debit_date,
      totalAmount: cycle.total_amount,
      status: cycle.status,
      debitTransactionId: cycle.debit_transaction_id,
      createdAt: cycle.created_at,
      updatedAt: cycle.updated_at,
    };
  }
}

export default CreditCard;
