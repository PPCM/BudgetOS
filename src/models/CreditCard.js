import { query, transaction as dbTransaction } from '../database/connection.js';
import { generateId, roundAmount, calculateDeferredDebitDate, getCycleForPurchase, formatDateISO } from '../utils/helpers.js';
import { NotFoundError } from '../utils/errors.js';
import { addMonths, setDate, subDays, endOfMonth, startOfMonth, format } from 'date-fns';

/**
 * Modèle CreditCard
 */
export class CreditCard {
  /**
   * Crée une nouvelle carte de crédit
   */
  static create(userId, data) {
    const id = generateId();
    
    query.run(`
      INSERT INTO credit_cards (
        id, user_id, account_id, linked_account_id, name, card_number_last4,
        expiration_date, debit_type, cycle_start_day, debit_day, debit_days_before_end,
        credit_limit, has_dedicated_account, auto_generate_debit, color, notes
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      id, userId, data.accountId, data.linkedAccountId || null, data.name,
      data.cardNumberLast4 || null, data.expirationDate || null, data.debitType, data.cycleStartDay || 1,
      data.debitDay || null, data.debitDaysBeforeEnd || null,
      data.creditLimit || null, data.hasDedicatedAccount ? 1 : 0,
      data.autoGenerateDebit !== false ? 1 : 0, data.color || '#EF4444',
      data.notes || null
    ]);
    
    // Créer le premier cycle si c'est une carte à débit différé
    if (data.debitType === 'deferred') {
      CreditCard.createCurrentCycle(id, userId);
    }
    
    return CreditCard.findById(id, userId);
  }
  
  /**
   * Trouve une carte par ID
   */
  static findById(id, userId) {
    const card = query.get(`
      SELECT cc.*, a.name as account_name, la.name as linked_account_name
      FROM credit_cards cc
      LEFT JOIN accounts a ON cc.account_id = a.id
      LEFT JOIN accounts la ON cc.linked_account_id = la.id
      WHERE cc.id = ? AND cc.user_id = ? AND cc.is_active = 1
    `, [id, userId]);
    
    return card ? CreditCard.format(card) : null;
  }
  
  /**
   * Trouve une carte ou lance une erreur
   */
  static findByIdOrFail(id, userId) {
    const card = CreditCard.findById(id, userId);
    if (!card) {
      throw new NotFoundError('Carte de crédit non trouvée');
    }
    return card;
  }
  
  /**
   * Liste les cartes d'un utilisateur
   */
  static findByUser(userId, options = {}) {
    const { isActive = true, includeBalances = true, status, sortBy = 'name', sortOrder = 'asc' } = options;

    let sql = `
      SELECT cc.*, a.name as account_name, la.name as linked_account_name
      FROM credit_cards cc
      LEFT JOIN accounts a ON cc.account_id = a.id
      LEFT JOIN accounts la ON cc.linked_account_id = la.id
      WHERE cc.user_id = ?
    `;
    const params = [userId];

    if (isActive !== undefined) {
      sql += ' AND cc.is_active = ?';
      params.push(isActive ? 1 : 0);
    }

    // Filtre par statut d'expiration
    if (status === 'active') {
      // Cartes non expirées ou sans date d'expiration
      sql += ` AND (cc.expiration_date IS NULL OR cc.expiration_date = '' OR
        (CAST(SUBSTR(cc.expiration_date, 4, 2) AS INTEGER) + 2000) * 100 + CAST(SUBSTR(cc.expiration_date, 1, 2) AS INTEGER) >=
        CAST(strftime('%Y', 'now') AS INTEGER) * 100 + CAST(strftime('%m', 'now') AS INTEGER))`;
    } else if (status === 'expired') {
      // Cartes expirées (avec date d'expiration passée)
      sql += ` AND cc.expiration_date IS NOT NULL AND cc.expiration_date != '' AND
        (CAST(SUBSTR(cc.expiration_date, 4, 2) AS INTEGER) + 2000) * 100 + CAST(SUBSTR(cc.expiration_date, 1, 2) AS INTEGER) <
        CAST(strftime('%Y', 'now') AS INTEGER) * 100 + CAST(strftime('%m', 'now') AS INTEGER)`;
    }

    // Tri
    const validSortFields = ['name', 'expiration_date', 'created_at'];
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'name';
    const order = sortOrder === 'desc' ? 'DESC' : 'ASC';

    // Pour le tri par date d'expiration, mettre les NULL à la fin
    if (sortField === 'expiration_date') {
      sql += ` ORDER BY CASE WHEN cc.expiration_date IS NULL OR cc.expiration_date = '' THEN 1 ELSE 0 END,
        (CAST(SUBSTR(cc.expiration_date, 4, 2) AS INTEGER) + 2000) * 100 + CAST(SUBSTR(cc.expiration_date, 1, 2) AS INTEGER) ${order}`;
    } else {
      sql += ` ORDER BY cc.${sortField} ${order}`;
    }

    const cards = query.all(sql, params);
    
    // Ajouter les soldes des cycles en cours si demandé
    if (includeBalances) {
      return cards.map(card => {
        const formatted = CreditCard.format(card);
        if (card.debit_type === 'deferred') {
          formatted.currentCycleBalance = CreditCard.getCurrentCycleBalance(card.id, userId);
          formatted.pendingDebitAmount = CreditCard.getPendingDebitAmount(card.id, userId);
        }
        return formatted;
      });
    }
    
    return cards.map(CreditCard.format);
  }
  
  /**
   * Met à jour une carte
   */
  static update(id, userId, data) {
    CreditCard.findByIdOrFail(id, userId);
    
    const allowedFields = [
      'linked_account_id', 'name', 'card_number_last4', 'expiration_date', 'debit_type',
      'cycle_start_day', 'debit_day', 'debit_days_before_end',
      'credit_limit', 'has_dedicated_account', 'auto_generate_debit', 'color', 'notes'
    ];
    
    const updates = [];
    const values = [];
    
    for (const [key, value] of Object.entries(data)) {
      const dbKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
      if (allowedFields.includes(dbKey)) {
        updates.push(`${dbKey} = ?`);
        values.push(typeof value === 'boolean' ? (value ? 1 : 0) : value);
      }
    }
    
    if (updates.length > 0) {
      values.push(id, userId);
      query.run(`UPDATE credit_cards SET ${updates.join(', ')} WHERE id = ? AND user_id = ?`, values);
    }
    
    return CreditCard.findById(id, userId);
  }
  
  /**
   * Supprime une carte (soft delete)
   */
  static delete(id, userId) {
    CreditCard.findByIdOrFail(id, userId);
    query.run('UPDATE credit_cards SET is_active = 0 WHERE id = ? AND user_id = ?', [id, userId]);
    return { deleted: true };
  }
  
  /**
   * Crée un cycle de facturation
   */
  static createCycle(cardId, userId, cycleStart, cycleEnd, debitDate) {
    const id = generateId();
    
    query.run(`
      INSERT INTO credit_card_cycles (id, credit_card_id, cycle_start_date, cycle_end_date, debit_date, status)
      VALUES (?, ?, ?, ?, ?, 'open')
    `, [id, cardId, cycleStart, cycleEnd, debitDate]);
    
    return id;
  }
  
  /**
   * Crée le cycle en cours pour une carte
   */
  static createCurrentCycle(cardId, userId) {
    const card = query.get('SELECT * FROM credit_cards WHERE id = ?', [cardId]);
    if (!card || card.debit_type !== 'deferred') return null;
    
    const today = new Date();
    const cycleStartDay = card.cycle_start_day || 1;
    
    // Déterminer les dates du cycle en cours
    let cycleStart, cycleEnd;
    if (today.getDate() >= cycleStartDay) {
      cycleStart = setDate(today, cycleStartDay);
      cycleEnd = subDays(setDate(addMonths(today, 1), cycleStartDay), 1);
    } else {
      cycleStart = setDate(addMonths(today, -1), cycleStartDay);
      cycleEnd = subDays(setDate(today, cycleStartDay), 1);
    }
    
    // Calculer la date de débit
    let debitDate;
    if (card.debit_day) {
      debitDate = setDate(addMonths(cycleEnd, 1), card.debit_day);
    } else if (card.debit_days_before_end) {
      debitDate = subDays(endOfMonth(addMonths(cycleEnd, 1)), card.debit_days_before_end);
    } else {
      debitDate = setDate(addMonths(cycleEnd, 1), 5);
    }
    
    // Vérifier si le cycle existe déjà
    const existing = query.get(`
      SELECT id FROM credit_card_cycles
      WHERE credit_card_id = ? AND cycle_start_date = ?
    `, [cardId, formatDateISO(cycleStart)]);
    
    if (existing) return existing.id;
    
    return CreditCard.createCycle(
      cardId, userId,
      formatDateISO(cycleStart),
      formatDateISO(cycleEnd),
      formatDateISO(debitDate)
    );
  }
  
  /**
   * Obtient le cycle en cours d'une carte
   */
  static getCurrentCycle(cardId, userId) {
    CreditCard.findByIdOrFail(cardId, userId);
    
    const cycle = query.get(`
      SELECT * FROM credit_card_cycles
      WHERE credit_card_id = ? AND status = 'open'
      ORDER BY cycle_start_date DESC
      LIMIT 1
    `, [cardId]);
    
    return cycle ? CreditCard.formatCycle(cycle) : null;
  }
  
  /**
   * Liste les cycles d'une carte
   */
  static getCycles(cardId, userId, options = {}) {
    CreditCard.findByIdOrFail(cardId, userId);
    
    const { status, startDate, endDate, page = 1, limit = 12 } = options;
    
    let sql = 'SELECT * FROM credit_card_cycles WHERE credit_card_id = ?';
    const params = [cardId];
    
    if (status) {
      sql += ' AND status = ?';
      params.push(status);
    }
    
    if (startDate) {
      sql += ' AND cycle_start_date >= ?';
      params.push(startDate);
    }
    
    if (endDate) {
      sql += ' AND cycle_end_date <= ?';
      params.push(endDate);
    }
    
    sql += ' ORDER BY cycle_start_date DESC LIMIT ? OFFSET ?';
    params.push(limit, (page - 1) * limit);
    
    const cycles = query.all(sql, params);
    
    // Ajouter le montant total de chaque cycle
    return cycles.map(cycle => {
      const formatted = CreditCard.formatCycle(cycle);
      formatted.totalAmount = CreditCard.getCycleTotal(cycle.id);
      formatted.transactionCount = CreditCard.getCycleTransactionCount(cycle.id);
      return formatted;
    });
  }
  
  /**
   * Obtient le total d'un cycle
   */
  static getCycleTotal(cycleId) {
    const result = query.get(`
      SELECT COALESCE(SUM(ABS(amount)), 0) as total
      FROM transactions
      WHERE credit_card_cycle_id = ?
    `, [cycleId]);
    
    return roundAmount(result?.total || 0);
  }
  
  /**
   * Compte les transactions d'un cycle
   */
  static getCycleTransactionCount(cycleId) {
    const result = query.get(`
      SELECT COUNT(*) as count FROM transactions WHERE credit_card_cycle_id = ?
    `, [cycleId]);
    
    return result?.count || 0;
  }
  
  /**
   * Obtient le solde du cycle en cours
   */
  static getCurrentCycleBalance(cardId, userId) {
    const cycle = CreditCard.getCurrentCycle(cardId, userId);
    if (!cycle) return 0;
    
    return CreditCard.getCycleTotal(cycle.id);
  }
  
  /**
   * Obtient le montant des débits en attente
   */
  static getPendingDebitAmount(cardId, userId) {
    const result = query.get(`
      SELECT COALESCE(SUM(total_amount), 0) as total
      FROM credit_card_cycles
      WHERE credit_card_id = ? AND status = 'pending'
    `, [cardId]);
    
    return roundAmount(result?.total || 0);
  }
  
  /**
   * Obtient les transactions d'un cycle
   */
  static getCycleTransactions(cycleId, userId) {
    const transactions = query.all(`
      SELECT t.*, c.name as category_name
      FROM transactions t
      LEFT JOIN categories c ON t.category_id = c.id
      WHERE t.credit_card_cycle_id = ? AND t.user_id = ?
      ORDER BY t.purchase_date DESC, t.date DESC
    `, [cycleId, userId]);
    
    return transactions.map(tx => ({
      id: tx.id,
      amount: tx.amount,
      description: tx.description,
      date: tx.date,
      purchaseDate: tx.purchase_date,
      categoryId: tx.category_id,
      categoryName: tx.category_name,
      status: tx.status,
    }));
  }
  
  /**
   * Assigne une transaction à un cycle
   */
  static assignTransactionToCycle(transactionId, cardId, userId) {
    const card = CreditCard.findByIdOrFail(cardId, userId);
    if (card.debitType !== 'deferred') return null;
    
    const tx = query.get('SELECT * FROM transactions WHERE id = ? AND user_id = ?', [transactionId, userId]);
    if (!tx) return null;
    
    const purchaseDate = tx.purchase_date || tx.date;
    const cycle = getCycleForPurchase(purchaseDate, card.cycleStartDay);
    
    // Trouver ou créer le cycle
    let cycleRecord = query.get(`
      SELECT id FROM credit_card_cycles
      WHERE credit_card_id = ? AND cycle_start_date = ?
    `, [cardId, cycle.start]);
    
    if (!cycleRecord) {
      // Calculer la date de débit
      const cycleEndDate = new Date(cycle.end);
      let debitDate;
      if (card.debitDay) {
        debitDate = setDate(addMonths(cycleEndDate, 1), card.debitDay);
      } else if (card.debitDaysBeforeEnd) {
        debitDate = subDays(endOfMonth(addMonths(cycleEndDate, 1)), card.debitDaysBeforeEnd);
      } else {
        debitDate = setDate(addMonths(cycleEndDate, 1), 5);
      }
      
      const cycleId = CreditCard.createCycle(cardId, userId, cycle.start, cycle.end, formatDateISO(debitDate));
      cycleRecord = { id: cycleId };
    }
    
    // Assigner la transaction au cycle
    query.run(`
      UPDATE transactions
      SET credit_card_cycle_id = ?, accounting_date = ?
      WHERE id = ?
    `, [cycleRecord.id, cycle.end, transactionId]);
    
    // Mettre à jour le total du cycle
    const total = CreditCard.getCycleTotal(cycleRecord.id);
    query.run('UPDATE credit_card_cycles SET total_amount = ? WHERE id = ?', [total, cycleRecord.id]);
    
    return cycleRecord.id;
  }
  
  /**
   * Génère le débit mensuel d'un cycle
   */
  static generateCycleDebit(cycleId, userId) {
    const cycle = query.get('SELECT * FROM credit_card_cycles WHERE id = ?', [cycleId]);
    if (!cycle || cycle.status !== 'pending') return null;
    
    const card = query.get('SELECT * FROM credit_cards WHERE id = ?', [cycle.credit_card_id]);
    if (!card || !card.linked_account_id) return null;
    
    const debitId = generateId();
    
    dbTransaction(() => {
      // Créer la transaction de débit
      query.run(`
        INSERT INTO transactions (
          id, user_id, account_id, credit_card_id, credit_card_cycle_id,
          amount, description, date, status, type
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'cleared', 'expense')
      `, [
        debitId, userId, card.linked_account_id, card.id, cycleId,
        -cycle.total_amount, `Prélèvement carte ${card.name}`,
        cycle.debit_date
      ]);
      
      // Marquer le cycle comme débité
      query.run(`
        UPDATE credit_card_cycles
        SET status = 'debited', debit_transaction_id = ?
        WHERE id = ?
      `, [debitId, cycleId]);
    });
    
    return debitId;
  }
  
  /**
   * Formate une carte pour l'API
   */
  static format(card) {
    return {
      id: card.id,
      userId: card.user_id,
      accountId: card.account_id,
      accountName: card.account_name,
      linkedAccountId: card.linked_account_id,
      linkedAccountName: card.linked_account_name,
      name: card.name,
      cardNumberLast4: card.card_number_last4,
      expirationDate: card.expiration_date,
      debitType: card.debit_type,
      cycleStartDay: card.cycle_start_day,
      debitDay: card.debit_day,
      debitDaysBeforeEnd: card.debit_days_before_end,
      creditLimit: card.credit_limit,
      hasDedicatedAccount: Boolean(card.has_dedicated_account),
      autoGenerateDebit: Boolean(card.auto_generate_debit),
      isActive: Boolean(card.is_active),
      color: card.color,
      notes: card.notes,
      createdAt: card.created_at,
      updatedAt: card.updated_at,
    };
  }
  
  /**
   * Formate un cycle pour l'API
   */
  static formatCycle(cycle) {
    return {
      id: cycle.id,
      creditCardId: cycle.credit_card_id,
      cycleStartDate: cycle.cycle_start_date,
      cycleEndDate: cycle.cycle_end_date,
      debitDate: cycle.debit_date,
      totalAmount: cycle.total_amount,
      status: cycle.status,
      debitTransactionId: cycle.debit_transaction_id,
      createdAt: cycle.created_at,
      updatedAt: cycle.updated_at,
    };
  }
}

export default CreditCard;
