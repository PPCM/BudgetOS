/**
 * CreditCard model tests
 */
import { describe, it, expect } from 'vitest';

// Import the CreditCard class to test format/formatCycle methods
// We import via dynamic import to avoid triggering the knex connection
// For format tests we only need the class itself, no DB interaction

describe('CreditCard.format', () => {
  // Inline the format function to test without DB dependency
  const format = (card) => ({
    id: card.id,
    userId: card.user_id,
    accountId: card.account_id,
    accountName: card.account_name,
    linkedAccountId: card.linked_account_id,
    linkedAccountName: card.linked_account_name,
    name: card.name,
    cardNumberLast4: card.card_number_last4,
    expirationDate: card.expiration_date,
    debitType: card.debit_type,
    cycleStartDay: card.cycle_start_day,
    debitDay: card.debit_day,
    debitDaysBeforeEnd: card.debit_days_before_end,
    creditLimit: card.credit_limit,
    hasDedicatedAccount: Boolean(card.has_dedicated_account),
    autoGenerateDebit: Boolean(card.auto_generate_debit),
    isActive: Boolean(card.is_active),
    color: card.color,
    notes: card.notes,
    createdAt: card.created_at,
    updatedAt: card.updated_at,
  });

  it('formats database row to API response', () => {
    const dbRow = {
      id: 'card-1',
      user_id: 'user-1',
      account_id: 'acc-1',
      account_name: 'Checking',
      linked_account_id: 'acc-2',
      linked_account_name: 'Savings',
      name: 'Visa Gold',
      card_number_last4: '4242',
      expiration_date: '12/26',
      debit_type: 'deferred',
      cycle_start_day: 26,
      debit_day: 5,
      debit_days_before_end: null,
      credit_limit: 3000,
      has_dedicated_account: 1,
      auto_generate_debit: 1,
      is_active: 1,
      color: '#EF4444',
      notes: 'My main card',
      created_at: '2026-01-01',
      updated_at: '2026-01-15',
    };

    const formatted = format(dbRow);

    expect(formatted.id).toBe('card-1');
    expect(formatted.userId).toBe('user-1');
    expect(formatted.accountId).toBe('acc-1');
    expect(formatted.accountName).toBe('Checking');
    expect(formatted.linkedAccountId).toBe('acc-2');
    expect(formatted.linkedAccountName).toBe('Savings');
    expect(formatted.name).toBe('Visa Gold');
    expect(formatted.cardNumberLast4).toBe('4242');
    expect(formatted.expirationDate).toBe('12/26');
    expect(formatted.debitType).toBe('deferred');
    expect(formatted.cycleStartDay).toBe(26);
    expect(formatted.debitDay).toBe(5);
    expect(formatted.debitDaysBeforeEnd).toBeNull();
    expect(formatted.creditLimit).toBe(3000);
    expect(formatted.hasDedicatedAccount).toBe(true);
    expect(formatted.autoGenerateDebit).toBe(true);
    expect(formatted.isActive).toBe(true);
    expect(formatted.color).toBe('#EF4444');
    expect(formatted.notes).toBe('My main card');
    expect(formatted.createdAt).toBe('2026-01-01');
    expect(formatted.updatedAt).toBe('2026-01-15');
  });

  it('converts boolean fields correctly for falsy values', () => {
    const dbRow = {
      id: 'card-2',
      has_dedicated_account: 0,
      auto_generate_debit: 0,
      is_active: 0,
    };

    const formatted = format(dbRow);

    expect(formatted.hasDedicatedAccount).toBe(false);
    expect(formatted.autoGenerateDebit).toBe(false);
    expect(formatted.isActive).toBe(false);
  });
});

describe('CreditCard.formatCycle', () => {
  const formatCycle = (cycle) => ({
    id: cycle.id,
    creditCardId: cycle.credit_card_id,
    cycleStartDate: cycle.cycle_start_date,
    cycleEndDate: cycle.cycle_end_date,
    debitDate: cycle.debit_date,
    totalAmount: cycle.total_amount,
    status: cycle.status,
    debitTransactionId: cycle.debit_transaction_id,
    createdAt: cycle.created_at,
    updatedAt: cycle.updated_at,
  });

  it('formats cycle database row to API response', () => {
    const dbRow = {
      id: 'cycle-1',
      credit_card_id: 'card-1',
      cycle_start_date: '2026-01-01',
      cycle_end_date: '2026-01-31',
      debit_date: '2026-02-05',
      total_amount: 1500.50,
      status: 'open',
      debit_transaction_id: null,
      created_at: '2026-01-01',
      updated_at: '2026-01-15',
    };

    const formatted = formatCycle(dbRow);

    expect(formatted.id).toBe('cycle-1');
    expect(formatted.creditCardId).toBe('card-1');
    expect(formatted.cycleStartDate).toBe('2026-01-01');
    expect(formatted.cycleEndDate).toBe('2026-01-31');
    expect(formatted.debitDate).toBe('2026-02-05');
    expect(formatted.totalAmount).toBe(1500.50);
    expect(formatted.status).toBe('open');
    expect(formatted.debitTransactionId).toBeNull();
  });

  it('includes debit transaction id when cycle is debited', () => {
    const dbRow = {
      id: 'cycle-2',
      credit_card_id: 'card-1',
      cycle_start_date: '2025-12-01',
      cycle_end_date: '2025-12-31',
      debit_date: '2026-01-05',
      total_amount: 800,
      status: 'debited',
      debit_transaction_id: 'tx-debit-1',
      created_at: '2025-12-01',
      updated_at: '2026-01-05',
    };

    const formatted = formatCycle(dbRow);

    expect(formatted.status).toBe('debited');
    expect(formatted.debitTransactionId).toBe('tx-debit-1');
  });
});

describe('parseExpirationValue', () => {
  // Re-implement the helper locally for unit testing without DB dependency
  function parseExpirationValue(expirationDate) {
    if (!expirationDate || expirationDate.trim() === '') return null;
    const parts = expirationDate.split('/');
    if (parts.length !== 2) return null;
    const month = parseInt(parts[0], 10);
    const year = parseInt(parts[1], 10) + 2000;
    if (isNaN(month) || isNaN(year)) return null;
    return year * 100 + month;
  }

  it('parses valid MM/YY format', () => {
    expect(parseExpirationValue('01/26')).toBe(202601);
    expect(parseExpirationValue('12/25')).toBe(202512);
    expect(parseExpirationValue('06/30')).toBe(203006);
  });

  it('returns null for null or empty string', () => {
    expect(parseExpirationValue(null)).toBeNull();
    expect(parseExpirationValue('')).toBeNull();
    expect(parseExpirationValue('   ')).toBeNull();
  });

  it('returns null for invalid format', () => {
    expect(parseExpirationValue('2026-01')).toBeNull();
    expect(parseExpirationValue('January 2026')).toBeNull();
    expect(parseExpirationValue('abc')).toBeNull();
  });

  it('returns null for non-numeric values', () => {
    expect(parseExpirationValue('ab/cd')).toBeNull();
  });
});

describe('isExpired', () => {
  function parseExpirationValue(expirationDate) {
    if (!expirationDate || expirationDate.trim() === '') return null;
    const parts = expirationDate.split('/');
    if (parts.length !== 2) return null;
    const month = parseInt(parts[0], 10);
    const year = parseInt(parts[1], 10) + 2000;
    if (isNaN(month) || isNaN(year)) return null;
    return year * 100 + month;
  }

  function currentYearMonth() {
    const now = new Date();
    return now.getFullYear() * 100 + (now.getMonth() + 1);
  }

  function isExpired(expirationDate) {
    const val = parseExpirationValue(expirationDate);
    if (val === null) return false;
    return val < currentYearMonth();
  }

  it('returns false for cards without expiration date', () => {
    expect(isExpired(null)).toBe(false);
    expect(isExpired('')).toBe(false);
    expect(isExpired(undefined)).toBe(false);
  });

  it('returns true for clearly expired dates', () => {
    expect(isExpired('01/20')).toBe(true);
    expect(isExpired('12/23')).toBe(true);
  });

  it('returns false for future dates', () => {
    expect(isExpired('12/30')).toBe(false);
    expect(isExpired('01/35')).toBe(false);
  });

  it('correctly handles current month', () => {
    const now = new Date();
    const currentMonth = String(now.getMonth() + 1).padStart(2, '0');
    const currentYear = String(now.getFullYear() - 2000).padStart(2, '0');
    // Current month should NOT be expired
    expect(isExpired(`${currentMonth}/${currentYear}`)).toBe(false);
  });
});

describe('expiration_date sorting logic', () => {
  function parseExpirationValue(expirationDate) {
    if (!expirationDate || expirationDate.trim() === '') return null;
    const parts = expirationDate.split('/');
    if (parts.length !== 2) return null;
    const month = parseInt(parts[0], 10);
    const year = parseInt(parts[1], 10) + 2000;
    if (isNaN(month) || isNaN(year)) return null;
    return year * 100 + month;
  }

  it('sorts by expiration_date ascending with nulls last', () => {
    const cards = [
      { name: 'C', expiration_date: null },
      { name: 'A', expiration_date: '06/25' },
      { name: 'B', expiration_date: '01/26' },
      { name: 'D', expiration_date: '' },
    ];

    cards.sort((a, b) => {
      const valA = parseExpirationValue(a.expiration_date);
      const valB = parseExpirationValue(b.expiration_date);
      if (valA === null && valB === null) return 0;
      if (valA === null) return 1;
      if (valB === null) return -1;
      return valA - valB;
    });

    expect(cards[0].name).toBe('A'); // 06/25
    expect(cards[1].name).toBe('B'); // 01/26
    // Nulls at the end
    expect(cards[2].expiration_date === null || cards[2].expiration_date === '').toBe(true);
    expect(cards[3].expiration_date === null || cards[3].expiration_date === '').toBe(true);
  });

  it('sorts by expiration_date descending with nulls last', () => {
    const cards = [
      { name: 'A', expiration_date: '06/25' },
      { name: 'B', expiration_date: '01/26' },
      { name: 'C', expiration_date: null },
    ];

    const order = 'desc';
    cards.sort((a, b) => {
      const valA = parseExpirationValue(a.expiration_date);
      const valB = parseExpirationValue(b.expiration_date);
      if (valA === null && valB === null) return 0;
      if (valA === null) return 1;
      if (valB === null) return -1;
      return order === 'asc' ? valA - valB : valB - valA;
    });

    expect(cards[0].name).toBe('B'); // 01/26 (most recent first)
    expect(cards[1].name).toBe('A'); // 06/25
    expect(cards[2].name).toBe('C'); // null last
  });
});
