import { z } from 'zod';

/**
 * Debit types
 */
export const debitTypes = ['immediate', 'deferred'];

/**
 * Base credit card schema
 */
const creditCardBaseSchema = z.object({
  accountId: z.string().uuid('Invalid account ID'),
  linkedAccountId: z.string().uuid('Invalid linked account ID').nullable().optional(),
  name: z.string().min(1, 'Name required').max(100, 'Name too long').trim(),
  cardNumberLast4: z.string().length(4).regex(/^\d{4}$/, 'Invalid format').optional(),
  expirationDate: z.string().min(1, 'Expiration date required').regex(/^(0[1-9]|1[0-2])\/\d{2}$/, 'Invalid format (MM/YY)'),
  debitType: z.enum(debitTypes, { errorMap: () => ({ message: 'Invalid debit type' }) }),
  cycleStartDay: z.number().int().min(1).max(28).default(1),
  debitDay: z.number().int().min(1).max(28).nullable().optional(),
  debitDaysBeforeEnd: z.number().int().min(0).max(10).nullable().optional(),
  creditLimit: z.number().positive().nullable().optional(),
  hasDedicatedAccount: z.boolean().default(false),
  autoGenerateDebit: z.boolean().default(true),
  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/).default('#EF4444'),
  notes: z.string().max(1000).optional(),
});

/**
 * Credit card creation schema
 */
export const createCreditCardSchema = creditCardBaseSchema.refine((data) => {
  if (data.debitType === 'deferred') {
    return data.debitDay != null || data.debitDaysBeforeEnd != null;
  }
  return true;
}, { message: 'For deferred debit, specify the debit day or D-X', path: ['debitDay'] });

/**
 * Credit card update schema
 */
export const updateCreditCardSchema = creditCardBaseSchema.omit({ accountId: true }).partial();

/**
 * URL parameters schema
 */
export const creditCardIdParamSchema = z.object({
  id: z.string().uuid('Invalid card ID'),
});

/**
 * Query schema for cycles
 */
export const listCyclesQuerySchema = z.object({
  status: z.enum(['open', 'pending', 'debited']).optional(),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().max(50).default(12),
});
